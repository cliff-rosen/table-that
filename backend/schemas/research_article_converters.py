"""
Research Article Converters

This module provides conversion functions between source-specific article formats
(PubMed, Google Scholar) and the unified CanonicalResearchArticle format for
consistent workbench representation.
"""

from typing import Dict, Any, Optional
from datetime import datetime

from schemas.canonical_types import (
    CanonicalResearchArticle,
    CanonicalScholarArticle
)
from services.pubmed_service import PubMedArticle

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from services.google_scholar_service import GoogleScholarArticle


def pubmed_article_to_research(article: PubMedArticle) -> CanonicalResearchArticle:
    """
    Convert a PubMedArticle (XML parse output) directly to CanonicalResearchArticle.

    Args:
        article: PubMedArticle object from pubmed_service XML parsing

    Returns:
        Unified research article format
    """
    # Convert comma-separated authors string to list
    authors = []
    if article.authors:
        if isinstance(article.authors, str):
            authors = [a.strip() for a in article.authors.split(',') if a.strip()]
        elif isinstance(article.authors, list):
            authors = article.authors

    return CanonicalResearchArticle(
        id=f"pubmed_{article.PMID}",
        source="pubmed",
        pmid=article.PMID,
        title=article.title or "[No title available]",
        authors=authors,
        abstract=article.abstract or "[No abstract available]",
        snippet=None,
        journal=article.journal or "[Unknown journal]",
        # Honest date fields directly from PubMedArticle
        pub_year=article.pub_year,
        pub_month=article.pub_month,
        pub_day=article.pub_day,
        # PubMed-specific date fields (convert empty strings to None)
        date_completed=article.comp_date if article.comp_date else None,
        date_revised=article.date_revised if article.date_revised else None,
        date_entered=article.entry_date if article.entry_date else None,
        doi=article.doi if article.doi else None,
        url=f"https://pubmed.ncbi.nlm.nih.gov/{article.PMID}/" if article.PMID else None,
        pdf_url=None,
        keywords=[],
        mesh_terms=[],
        categories=[],
        citation_count=None,
        cited_by_url=None,
        related_articles_url=f"https://pubmed.ncbi.nlm.nih.gov/?linkname=pubmed_pubmed&from_uid={article.PMID}" if article.PMID else None,
        versions_url=None,
        search_position=None,
        relevance_score=None,
        extracted_features=None,
        quality_scores=None,
        source_metadata={
            "volume": article.volume,
            "issue": article.issue,
            "pages": article.pages,
            "medium": article.medium,
            "article_date": article.article_date,
        },
        indexed_at=None,
        retrieved_at=datetime.utcnow().isoformat()
    )


def scholar_to_research_article(scholar_article: 'GoogleScholarArticle', position: Optional[int] = None) -> CanonicalResearchArticle:
    """
    Convert a GoogleScholarArticle to the unified CanonicalResearchArticle format.

    Args:
        scholar_article: Google Scholar article to convert (new GoogleScholarArticle class)
        position: Position in search results (optional)

    Returns:
        Unified research article format
    """
    return CanonicalResearchArticle(
        id=scholar_article.id,  # Use the ID generated by GoogleScholarArticle
        source="google_scholar",
        title=scholar_article.title,
        authors=scholar_article.authors,
        abstract=(getattr(scholar_article, 'abstract', None) or scholar_article.snippet),
        snippet=scholar_article.snippet,
        journal=scholar_article.journal,  # GoogleScholarArticle extracts this
        # Honest date fields - Scholar only provides year
        pub_year=scholar_article.pub_year,
        pub_month=None,  # Scholar doesn't provide month
        pub_day=None,  # Scholar doesn't provide day
        doi=scholar_article.doi,  # GoogleScholarArticle extracts DOI
        url=scholar_article.link,
        pdf_url=scholar_article.pdf_link,
        keywords=[],  # Scholar doesn't provide keywords directly
        mesh_terms=[],  # Scholar doesn't have MeSH terms
        categories=[],  # Could be inferred from content
        citation_count=scholar_article.cited_by_count,
        cited_by_url=scholar_article.cited_by_link,
        related_articles_url=scholar_article.related_pages_link,
        versions_url=scholar_article.versions_link,
        search_position=position or scholar_article.position,
        relevance_score=None,  # Will be populated by feature extraction
        extracted_features=None,  # Will be populated by feature extraction
        quality_scores=None,  # Will be populated by feature extraction
        source_metadata={
            "position": scholar_article.position,
            "publication_info": scholar_article.publication_info
        },
        metadata=getattr(scholar_article, 'metadata', None),  # Pass through enrichment metadata
        indexed_at=None,
        retrieved_at=datetime.utcnow().isoformat()
    )


def enrich_research_article_with_features(
    research_article: CanonicalResearchArticle,
    features: Dict[str, Any]
) -> CanonicalResearchArticle:
    """
    Add extracted features to a research article.

    Args:
        research_article: The research article to enrich
        features: Extracted features from LLM analysis

    Returns:
        Research article with extracted features
    """
    # Extract relevance score if present
    relevance_score = features.get('relevance_score')

    # Create quality scores dictionary
    quality_scores = {}
    if 'confidence_score' in features:
        quality_scores['confidence'] = features['confidence_score']
    if relevance_score is not None:
        quality_scores['relevance'] = float(relevance_score)

    # Create a copy with enriched data
    enriched_article = research_article.copy(deep=True)
    enriched_article.extracted_features = features
    enriched_article.relevance_score = relevance_score
    enriched_article.quality_scores = quality_scores if quality_scores else None

    return enriched_article
